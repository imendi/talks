Before addressing the individual points in Loïc’s mail, I want to get a couple of facts about elvis[1] and erlang_standards[2] straight, to eliminate (or alleviate) some doubts about them:
  First of all, a note on their purposes:

  1. Elvis is an open-source configurable and extensible style-checker, intended to be used by any Erlang programmer in the world, therefore its “standards” (a.k.a. rules) are as flexible as they may be (e.g. the rule is defined as “nesting_level, [MaxNestingLevel]” so that each dev can pick their favourite MaxNestingLevel)
  2. erlang_standards is the set of standards that we (at Inaka) enforce in our Erlang code. Since they reflect _our_ take on style rules, they’re not as flexible as elvis’ rules (e.g. the rule says "Try not to nest more than 3 levels deep.”, i.e. MaxNestingLevel = 3 for us).

  Now, one of our goals when building elvis was for it to be as flexible as possible. To achieve that goal, we provided a couple of ways in which devs can configure it, namely:
  - if you use elvis as a command line tool, you MUST provide a configuration file (there is an example on the elvis repo [3], but there are NO default values). That way you MUST decide which rules you want to enforce explicitly.
  - those rules in elvis.config, are just MFAs that all happen to be in the elvis_style module, but can actually be in any module you want (granted, if you want to apply your own rules you need to run elvis in an Erlang shell with access to your modules, but I already opened an issue there to see if we can find a way to handle the same behaviour in the escript version)
  - if you use elvis as a server integration with github [4] there is a default set of rules, BUT you can override it by simply placing an elvis.config file in the root folder of your repo. Granted: you can’t run rules defined in your own modules there, sorry about that :) You can submit them as pull requests to elvis and, once they’re merged, they’ll soon be available at the service ;)

  So, in a nutshell: Elvis should fit your needs and your rules, not the ones at Inaka. If you think that’s not the case, and it needs further integration/configuration/simplicity… please open an issue on github or better send us a PR.

  Now, moving on to erlang_standards. As much as I would love that repo to become a centralised list of standards for the whole erlang community, I would argue that if that’s going to be the case, it shouldn’t be in Inaka’s github, but rather on erlang’s github (https://github.com/erlang/erlang_standards) or something similar (BTW: I’m totally fine giving you ownership of the repo, OTP guys… I would then fork it at Inaka and adapt the rules that we, at the company, want to enforce but are not massively accepted by the community). In the meantime, as I said, it will only reflect the ideas of the ~8 erlangers that were/are working at Inaka. We accept contributions because we love good and constructive debate, but we don’t expect anybody outside our company (well… we don’t even expect everybody INSIDE our company) to like them :)
